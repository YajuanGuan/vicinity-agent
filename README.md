# Overview

VICINITY Agent serves as the interface between VICINITY GateWay and VICINITY Adapter.

## Adapter role

Adapter represents the *driver* to specific infrastructure and
provides just very basic interactions with objects behind it, namely:
* provide discovery information in *Common VICINITY Thing Description* format
* get/set object property
* get status/execute object action
* open/subscribe to event channel
* publish/receive event

Every object in VICINITY has **its unique VICINITY identifier (oid)**,
but adapter **always uses the internal object identifiers (infrastructure-id)**, specific for its infrastructure.

## Agent role

Agent is the functional extension of Adapter. The role of Agent is to make the life of Adapter developers easier.

The responsibility of agent is:
* to translate between object infrastructure identifiers (**infrastructure-id**) used by Adapter
and VICINITY identifiers (**oid**).
* to automatize common tasks, like **discovery/configuration** and **opening/subscribing to event channels**
* to translate between common VICINITY consumption/eventing services (implemented in GTW API) into specific Adapter services, depending
 how they are described in Thing Descriptions
* translating Adapter requests for consumption/event services into common VICINITY services (implemented in GTW API), with proper credentials


Now, in details.

# Installation guide

## Deployment and re-deployment

Agent comes with and requires the following directory structure:
```
config/
    db/
    agent-config.json
logs/
agent.jar
agent.sh
```

**!!!VERY IMPORTANT!!!** folder **config/db** contains local agent configuration storage, with all mappings and credentials.
Once any content in this folder is manually removed or edited, local configuration may be lost and all objects in
this node may be treated as new. This leads to dropping whole configuration also in Neighbourhood manager, including
friendships and permissions.

*config/agent-config.json* contains the agent configuration
*logs/* contains all agent logs files
*agent.jar* is the executable
*agent.sh* is the script to run/stop the agent

Run the agent:
```
#!shell

./agent.sh
```

Stop the agent:
```
#!shell

./agent.sh stop
```

To redeploy the Agent, simply stop the agent, replace the **agent.jar** file and run it again.


## Configuration

The agent configuration can be found in *config/agent-config.json* file. The config looks as follows:
```
#!json
{
    "credentials": {
        "agent-id": "agent id generated by Neighbourhood Manager",
        "password": "agent id generated by Neighbourhood Manager"
    },
    "gateway-api-endpoint": "http://localhost:8181/api",
    "adapters": [
        {
            "adapter-id": "adapter-1",
            "endpoint": "http://localhost:9995/adapter"
        }
    ]
}
```

Set agent credentials to **agent id** and **password** generated by Neighbourhood Manager, when VICINITY node
was created. Set the endpoint to GTW API. Add the list of Adapters to be handled by this agent.

**!!!VERY IMPORTANT!!!** For each adapter it is mandatory to set the endpoint and **adapter-id**. **adapter-id** is treated
as persistent, in Agent, internally, each object identifier is tied with adapter identifier. In current
implementation, the **adapter-id** is the only clue, how to tie the concrete object with concrete adapter
(especially in cases, when multiple adapters may contain objects with same identifiers). Once adapter identifiers are
changed, all existing objects behind this adapter are treated as new. They will receive new credentials, all friendships
will be lost.

Additional configuration can be changed in **agent.sh** script. If needed, it is possible to change the port, where Agent will run,
the log folder destination and the path to agent config json file. Just edit following variables in **agent.sh** script:

```
SERVER_PORT=9997
CONFIG_FILE=config/agent-config.json
LOGS_FOLDER=logs
```


## Agent response
Success:
```
{
    "status": "success"
    "data": {
        untouched payload object returned by requested component
    }
}
```

Failure:
```
{
    "status": "failure"
    "reason": "the reason of failure, as much known as possible",
}
```

# Auto discovery/configuration

Agent always holds the actual configuration of objects behind its Adapter(s).
The configuration always contains the actual list of objects presented by Adapter and their services (consumption/eventing).
For each object, there is specified unique mapping between object's **infrastructure-id** and VICINITY **oid**.
Agent also holds the object's credentials, that are **mandatory** for interaction between any pair of objects in VICINITY.

Auto Discovery process is launched, when Agent starts (by default) and is composed of following steps:
1. read the last active configuration of node from Neighbourhood Manager
2. read the actual thing descriptions from all its Adapters
3. make DIFF. Last active configuration and actual list of objects is compared, the result is
  * the list of missing objects to delete
  * the list of new objects to create
  * the list of objects to update; update is the change of any of mandatory properties and is interpreted as the violence to contract, thus the update is in Neighbourhood Manager executed as: delete/create object + drop all friendships; the result of update operation is the brand new object with new **oid** and credentials
  * the list of unchanged objects
4. the CRUD dance with Neighbourhood Manager, delete/create/update objects and their semantic models
5. actualize the actual configuration
6. log in all objects into P2P network
7. open channels to publish events
8. subscribe to channels to receive events

The result of auto discovery is the list of all active objects with actual credentials and their consumption/eventing services.
Using the actual configuration, the Agent can translate between common VICINITY services and Adapter services, using the proper credentials.

# Data consumption services

Data consumption services allows to read/set property value or execute/read status of action on the object.

**Important!** If object needs to use consumption services on another object, the proper permissions must be set in Neighbourhood manager.
Otherwise this interaction will be rejected on level of GTW API.

## Object properties


To read object property value, the Agent implements the endpoint:
```
GET : /objects/{oid}/properties/{pid}
```

To set object property value, the Agent implements the endpoint:
```
PUT : /objects/{oid}/properties/{pid}
```
PUT operation requires the payload with data structure specified in thing description for this property input to set the value.

For both operations, Agent enables two way interaction.


### Consuming property of remote object (from another VICINITY node)


If **object from this infrastructure** (for which this Agent runs) wants to get/set property of **remote object** (another VICINITY node),
in both calls, **the request header must contain key-value pair**:
```
infrastucture-id=infrastructure-id of requesting object
```
Agent finds the corresponding **oid** for requesting object matching **infrastructure-id** in header and translates
this request into corresponding GTW API call, setting the proper VICINITY credentials for requesting object.


### Consuming property of local object (in this VICINITY node)

If agent receives get/set property without the header **infrastucture-id**, the request is interpreted as consumption service
to object in this infrastructure. The agent translates:
* **oid** in request into **infrastructure-id** known in Adapter
* the endpoint to be called on Adapter

Property interaction pattern specification in Common Thing Description format:

```
{
    "pid": "property-unique-identifier",
    "monitors": "OntologyPropertyInstance",
    "output": {
        "units": "OntologyUnitInstance"
    },
    "read_links": [{
        "href": "/any-endpoint/in-adapter/to-read/{pid}"
    }],
    "write_links": [{
        "href": "/any-endpoint/in-adapter/to-set/{pid}"
    }]
}
```

Adapter is free to specify the endpoints to read/set property in form it requires. Endpoint to read property is specified
in field *read_links*, endpoint to set property in *write_links*. Endpoint can contain variables **{oid}** and **{pid}**, which are
replaced:
* **{oid}** -> infrastructure if of this object
* **{pid}** -> property unique identifier of property having this endpoint

In both cases, *read_links* and *write_links* are specified as arrays, however in actual implementation Agent takes and uses
only the first value in array.

Once transformations are done, the endpoint is executed on Adapter.