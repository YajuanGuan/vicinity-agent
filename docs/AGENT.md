# (Multi) Agent Service for integrators


VICINITY Agent serves as the interface between VICINITY GateWay and VICINITY Adapter.
Agent is the functional extension of Adapter. The role of Agent is to make the life of Adapter developers easier.

The responsibility of agent is:
* to translate between object infrastructure identifiers (**infrastructure-id**) used by Adapter
and VICINITY identifiers (**oid**).
* to automatize common tasks, like **discovery/configuration** and **opening/subscribing to event channels**
* to translate between common VICINITY consumption/eventing services (implemented in GTW API) into specific Adapter services, depending
 how they are described in Thing Descriptions
* translating Adapter requests for consumption/event services into common VICINITY services (implemented in GTW API), with proper credentials

Agent Service was adjusted to handle multiple client nodes, so it was enhanced from agent to multi-agent.
Agent is now service able to manage multiple agent configurations.
The purpose was to, again, make life of adapter developers easier. The main trigger was,
that if some service provider must run multiple client nodes (e.g. in the cloud), for
each client node, the separate software (adapter, agent, gtw), has to be deployed and runed.
If provider has to run really many client nodes, the management of deployed software
becomes critical (for each client node, there physically run three software components).
Switch to multi-agent concept enables to run only one physical deployment for as many client
nodes as needed.

Now, in details.

# Installation guide

## Deployment and re-deployment

Agent comes with and requires the following directory structure:
```
config/
    db/
    agents/
        agent-1-config.json
        ..
        agent-x-config.json
    service-config.json
logs/
agent.jar
agent.sh
```

*config/service-config.json* contains the service configuration shared by all included agents.
*agents/* contains configuration files for agents to be managed
*logs/* contains all agent logs files
*agent.jar* is the executable
*agent.sh* is the script to run/stop the agent


**!!!VERY IMPORTANT!!!** folder **config/db** contains local agent configuration storage, with all mappings and credentials.
Once any content in this folder is manually removed or edited, local configuration may be lost and all objects in
this node may be treated as new. This leads to dropping whole configuration also in Neighbourhood manager, including
friendships and permissions.

[DOWNLOAD AGENT SKELETON (structure above)](../agent-service/build)

Run the agent:
```
#!shell

./agent.sh
```

Stop the agent:
```
#!shell

./agent.sh stop
```

To redeploy the Agent, simply stop the agent, replace the **agent.jar** file and run it again.


## Configuration

The service configuration, shared by all included agents is located in *config/service-config.json* file.
Now it contails only the endpoint to GTW API.

```
config/service-config.json:
#!json
{
    "gateway-api-endpoint": "http://localhost:8181/api"
}
```

The configuration for all included agent components can be found in *config/agents/* folder. The config per each agent component looks as follows:
```
config/agents/any-agent-config.json:
#!json
{
    "credentials": {
        "agent-id": "agent id generated by Neighbourhood Manager",
        "password": "agent id generated by Neighbourhood Manager"
    },
    "adapters": [
        {
            "adapter-id": "unique id of adapter"
            "active-discovery": true/false
            "endpoint": "http://localhost:9995/adapter"
        }
    ],
    "events": {
        "channels": [
            {
                "infrastructure-id": "internal identifier of object publishing the event",
                "adapter-id": "adapter identifier of this object",
                "eid": "object event identifier",
            }
        ],
        "subscriptions": [
            {
                "oid": "VICINITY object id",
                "infrastructure-id": "internal identifier of object subscribing for the event",
                "adapter-id": "adapter identifier of subscriber object",
                "eid": "object event identifier",
            }
        ]
    }
}
```

Set agent credentials to **agent id** and **password** generated by Neighbourhood Manager, when VICINITY node
was created. Set the endpoint to GTW API. Add the list of Adapters to be handled by this agent.

### Configuration of adapters

One agent component may manage multiple adapters, **each adapter must provide its unique identifier**.

#### adapter-id

**adapter-id must be specific for whole agent service. Just ensure, it is unique!**
Agent service must be able to unambiguously decide, which object belongs to which adapter
and which adapter belongs to which agent.

Generate **adapter-id** as **unique hash code** and **store it in your adapter code**.
It will be required, when talking to agent, this prevents the ambiguity in
object identifiers (case, when different adapters contain objects with
identical infrastructure-id).

#### active-discovery

Discovery may be triggered by agent, but now, also by adapter proactively.
If you want your adapter to trigger the discovery, in agent config "adapters", use property
**"active-discovery": true/false**.

If set to true, agent will not try to invoke discovery, agent will wait for agent to do this.
When running node, adapter must be started as last component!

If set to false, agent will invoke discovery when started.
When running node, agent must be started as last component!

Default is : **"active-discovery": false**.

#### endpoint

**endpoint** parameter is optional.
When **endpoint** is not provided, that means, that only possible communication
is **adapter -> agent**. In this case, agent can not speak to adapter and
discovery must be invoked by adapter.

For this reason, **"active-discovery"** must be set to **true**.
If **"endpoint"** is missing and **"active-discovery"** is missing, **"active-discovery"** is set to **true** by default.


### Additional configuration

Additional configuration can be changed in **agent.sh** script. If needed, it is possible to change the port, where Agent will run,
the log folder destination and the path to agent config json file. Just edit following variables in **agent.sh** script:

```
SERVER_PORT=9997
CONFIG_FILE=config/service-config.json
AGENT_CONFIG_FOLDER=config/agents
LOGS_FOLDER=logs
```


## Agent response
The response of agent is always wrapped into following structure:

Success:
```
#!json
{
    "status": "success"
    "data": {
        untouched payload object returned by requested component
    }
}
```

Failure:
```
#!json
{
    "status": "failure"
    "reason": "the reason of failure, as much known as possible",
}
```


# Auto discovery/configuration

Agent always holds the actual configuration of objects behind its Adapter(s).
The configuration always contains the actual list of objects presented by Adapter and their services (consumption/eventing).
For each object, there is specified unique mapping between object's **infrastructure-id** and VICINITY **oid**.
Agent also holds the object's credentials, that are **mandatory** for interaction between any pair of objects in VICINITY.

Auto Discovery process is launched, when Agent starts (by default) and is composed of following steps:
1. read the last active configuration of node from Neighbourhood Manager
2. read the actual thing descriptions from all its Adapters
3. make DIFF. Last active configuration and actual list of objects is compared, the result is
    * the list of missing objects to delete
    * the list of new objects to create
    * the list of objects to update; update is the change of any of mandatory properties and is interpreted as the violence to contract, thus the update is in Neighbourhood Manager executed as: delete/create object + drop all friendships; the result of update operation is the brand new object with new **oid** and credentials
    * the list of unchanged objects
4. the CRUD dance with Neighbourhood Manager, delete/create/update objects and their semantic models
5. actualize the actual configuration
6. log in all objects into P2P network
7. open channels to publish events
8. subscribe to channels to receive events

The result of auto discovery is the list of all active objects with actual credentials and their consumption/eventing services.
Using the actual configuration, the Agent can translate between common VICINITY services and Adapter services, using the proper credentials.



# Data consumption services

Data consumption services allows to read/set property value or execute/read status of action on the object.

**Important!** If object needs to use consumption services on another object, the proper permissions must be set in Neighbourhood manager.
Otherwise this interaction will be rejected on level of GTW API.

## Object properties



### Consuming property of remote object (from another VICINITY node)

**Consuming of remote object property is always invoked by object behind the Adapter.** Thus, object must
have permissions to consume the remote object property and proper VICINITY credentials
of this object must be provided.

To read remote object property value, the Agent implements the endpoint:
```
GET : /remote/objects/{oid}/properties/{pid}
```

To set remote object property value, the Agent implements the endpoint:
```
PUT : /remote/objects/{oid}/properties/{pid}
```
PUT operation requires the payload with data structure specified in thing description for this property input to set the value.


If **object from this infrastructure** (for which this Agent runs) wants to get/set property of **remote object** (another VICINITY node),
in both calls, **the request header must contain key-value pairs**:
```
infrastucture-id=infrastructure-id of requesting object
adapter-id=identifier of adapter for this object
```

Agent finds the corresponding **oid** for requesting object matching **infrastructure-id** in header and translates
this request into corresponding GTW API call, setting the proper VICINITY credentials for requesting object.



### How agent processes the consumption of local object property (in this VICINITY node)

To read local object property value, the Agent implements the endpoint:
```
GET : /objects/{oid}/properties/{pid}
```

To set local object property value, the Agent implements the endpoint:
```
PUT : /objects/{oid}/properties/{pid}
```
PUT operation requires the payload with data structure specified in thing description for this property input to set the value.

When Agent receive the property consumption request, it translates this requests into corresponding Adapter endpoints and execute it.
This process is described in details in [Adapter interaction patterns](docs/ADAPTER.md#interaction-patterns)

## Object actions

TBD

# Eventing

Consumption services enable to read object properties by request. The eventing mechanism enables objects to publish
the values of their properties (or whatever needs to be published) once, the conditions are met.
So other object can receive data automatically, without explicitly requesting it.

The VICINITY eventing mechanism is implemented as publish/subscribe pattern.

## Event channel management

The name of event channel for object is always specified as: **/objects/{oid}/event/{eid}**. Any object can open its channel for
concrete event and publish data into it. Once the channel is open, other objects may subscribe to this channel. Once the object is subscribed to the channel,
Adapter of this object will receive events from this channel, when they appear.

Opening the channels and subscriptions may be done statically, using Agent configuration file; or dynamically on the fly.

### Static channel management

Opening the channels and subscriptions may be declared in Agent configuration file, field **events**.
```
#!json
    "events": {
        "channels": [
            {
                "infrastructure-id": "internal identifier of object publishing the event",
                "adapter-id": "adapter identifier of this object",
                "eid": "object event identifier",
            }
        ],
        "subscriptions": [
            {
                "oid": "VICINITY object id producing event",
                "eid": "object event to listen subscribe",

                "infrastructure-id": "internal identifier of object subscribing for the event",
                "adapter-id": "adapter identifier of subscriber object",
            }
        ]
    }

```

Field **channels** contains the array of declarations, for which object and its event the channel should be open.
As the channel is to be open for local object (within this VICINITY node), the **infrastructure-id** of object behind the Adapter
is used.
The channel **/objects/{oid}/events/{eid}** is open, where **oid** is VICINITY identifier of object with **infrastructure-id**.

Field **subscriptions** contains the array of declarations, to which channels the Adapter objects will listen.
The **infrastructure-id** specifies object behind the Adapter, which is subscribed to channel, the **oid** specifies the object producing event.
The object with **infrastructure-id** is subscribed to channel **/objects/{oid}/events/{eid}**, where **oid** is VICINITY identifier of object producing event.


Using this declaration, the Agent will create and subscribe to channels when it starts.

### Dynamic channel management

In some cases, some object in Adapter needs to open or subscribe to channel on the fly (depending on its internal logic).

To **open channel**, Agent provides the service:
```
POST /objects/{infrastructure-id}/events/{eid}/open
headers:
adapter-id=adapter for this object
```

Request parameter **infrastructure-id** specifies the identifier of object, which will publish the events.
The channel is open for this object.


The body of this request must be empty.

Agent translates this request into proper GTW API call, using credentials for object with **infrastructure-id**.

Just to note, the channel of object with **infrastructure-id** may be open by another object (e.g. value added service
may open the channel for sensor). The credentials will be provided for object with **infrastructure-id**, as if object
opened the channel by itself.


To **subscribe to channel**, Agent provides the service:
```
POST /objects/{oid}/events/{eid}/subscribe
headers:
infrastructure-id=internal object id
adapter-id=adapter for this object
```
The request parameter **oid** specifies the VICINITY oid of object, to which channel this subscription applies.


The request must contain the header with key **infrastructure-id**, which specifies the internal object,
that will listen to this channel.


The body of this request must be empty.

Agent translates this request into proper GTW API call, using credentials for object with **infrastructure-id**.

## Event management

### Publishing the event

Object, for which the channel is opened may publish data into this channel by using Agent service:
```
PUT /objects/{infrastructure-id}/events/{eid}/publish
headers:
adapter-id=adapter for this object
```
**infrastructure-id** in request is the identifier of local object publishing the event.


Body of this request must be JSON payload with published event data.

Agent translates this request into proper GTW API call, using credentials for object with **infrastructure-id**.


### Consuming the event

Agent automatically pass the events into Adapter, as they appear. If Adapter needs to listen to events, Adapter
must implement the service for event consumption (see [Adapter docs on event consumption](ADAPTER.md#consumption-of-events))

In current implementation, the Adapter is responsible for processing the events and passing them further to subscribed objects in Adapters.
